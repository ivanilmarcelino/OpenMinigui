#line 54 "S:\Mega\Dev\32\BCC\Minigui\include\i_var.ch"
  MEMVAR _HMG_SYSDATA
#line 14 "S:\Mega\Dev\32\BCC\Minigui\include\miniprint.ch"
  MEMVAR _HMG_MINIPRINT
#line 11 "demo.prg"
FUNCTION Main





   LOCAL cText := "MULTI-COLOR TEXT"
   LOCAL hFont





   LOCAL aColors := {  ( 164 + ( 196 * 256 ) + ( 0 * 65536 ) ), ( 96 + ( 169 * 256 ) + ( 23 * 65536 ) ), ( 0 + ( 138 * 256 ) + ( 0 * 65536 ) ), ( 0 + ( 171 * 256 ) + ( 169 * 65536 ) ), ( 27 + ( 161 * 256 ) + ( 226 * 65536 ) ),  ( 0 + ( 80 * 256 ) + ( 239 * 65536 ) ), ( 106 + ( 0 * 256 ) + ( 255 * 65536 ) ), ( 170 + ( 0 * 256 ) + ( 255 * 65536 ) ), ( 244 + ( 114 * 256 ) + ( 208 * 65536 ) ), ( 216 + ( 0 * 256 ) + ( 115 * 65536 ) ),  ( 162 + ( 0 * 256 ) + ( 37 * 65536 ) ), ( 229 + ( 20 * 256 ) + ( 0 * 65536 ) ), ( 250 + ( 104 * 256 ) + ( 0 * 65536 ) ), ( 240 + ( 163 * 256 ) + ( 10 * 65536 ) ), ( 227 + ( 200 * 256 ) + ( 0 * 65536 ) ),  ( 130 + ( 90 * 256 ) + ( 44 * 65536 ) ), ( 109 + ( 135 * 256 ) + ( 100 * 65536 ) ), ( 100 + ( 118 * 256 ) + ( 135 * 65536 ) ), ( 118 + ( 96 * 256 ) + ( 138 * 65536 ) ), ( 135 + ( 121 * 256 ) + ( 78 * 65536 ) ) }


   AShuffle( aColors )

   hFont := GetFontHandle( "Font_Text" )
   IF hFont == 0
      _DefineFont ( "Font_Text", "IMPACT", 48, .F., .F., .F., .F.,, .F., )
   ENDIF

   hFont := GetFontHandle( "Font_Text" )

   SetGlobalListener( "App_OnEvents" )








 _DefineWindow ( "Form_Main", cText, 0, 0, 600, 400, .F., .F., .F., .F., .F., {,}, {,},, ,, {|| InvalidateRect( iif ( _HMG_SYSDATA[218] == "C" , GetProperty ( _HMG_SYSDATA[254] , _HMG_SYSDATA[255] , "Handle" ) , GetProperty ( _HMG_SYSDATA[254] , "Handle" ) ), 0 )} , ,, , {|| App_OnPaint( iif ( _HMG_SYSDATA[218] == "C" , GetProperty ( _HMG_SYSDATA[254] , _HMG_SYSDATA[255] , "Handle" ) , GetProperty ( _HMG_SYSDATA[254] , "Handle" ) ), hFont, cText, aColors )} , .F. , .F. , .T. , , .F. , ,, , , ,, , , , , , , , , , .F. , {|| InvalidateRect( iif ( _HMG_SYSDATA[218] == "C" , GetProperty ( _HMG_SYSDATA[254] , _HMG_SYSDATA[255] , "Handle" ) , GetProperty ( _HMG_SYSDATA[254] , "Handle" ) ), 0 )} , , , .F. , , , , , .F. , .F. , , , .F. , , , )

      _BeginMessageBar( "StatusBar",, .F., "Arial", 12, .F., .F., .F., .F., )
         _DefineItemMessage( "STATUSITEM", , 0, 0, "Color Text",,, 0,,,, .F., HMG_n2RGB( GetSysColor( 28 ) ),, iif( .F. == .T., 2, iif( .F. == .T., 1, 0 ) ) )
      _EndMessageBar ()

      _DefineHotKey ( , 0 , 27 , {|| DoMethod ( _HMG_SYSDATA[254] , "Release" )} )

   _EndWindow ()

   DoMethod ( "Form_Main", "Center" )

   _ActivateWindow ( {"Form_Main"}, .F., , )

RETURN NIL




FUNCTION App_OnPaint( hWnd, hFont, cText, aColors )














   LOCAL aRect := { 0, 0, 0, 0 }
   LOCAL c, n, hDC, nRight, bk

   GetCliAreaRect( hWnd, aRect )


   SetProperty ( "Form_Main", "Statusbar" , "Item" , 1 , PadC( "Color Text", aRect[ 4 ] / 4 ) )

   hDC := GetDC( hWnd )


   n := DrawTextEx( hDC, cText, aRect, 32 + 1024, hFont, 0, @nRight )
   aRect[ 1 ] += ( aRect[ 3 ] - aRect[ 1 ] - n - GetProperty ( "Form_Main", "Statusbar" , "Height" ) - 2 ) / 2
   aRect[ 2 ] += Int( ( aRect[ 4 ] - nRight - GetBorderWidth() ) / 2 )


   bk := SetBkMode( hDC, 1 )
   FOR n := 1 TO Len( cText )
      c := SubStr( cText, n, 1 )
      DrawTextEx( hDC, c, aRect, 32 + 1024, hFont, 0, @nRight )
      DrawTextEx( hDC, c, aRect, 32, hFont, aColors[ n ] )
      aRect[ 2 ] := nRight
   NEXT
   SetBkMode( hDC, bk )

   ReleaseDC( hWnd, hDC )

RETURN NIL


FUNCTION App_OnEvents( hWnd, nMsg, wParam, lParam )














   LOCAL nResult
   LOCAL ControlCount, i, k, x

   SWITCH nMsg

   CASE 5

      ControlCount := Len ( _HMG_SYSDATA[137] )

      i := AScan ( _HMG_SYSDATA[94], hWnd )

      IF i > 0

            IF ( k := _HMG_SYSDATA[114] [i] ) > 0

               SendMessage( k, (0x0400 + 35), 0, 0 ) ; SendMessage( k, (0x0400 + 35), 0, 1 )
               SendMessage( k, (0x0400 + 27), 0, 0 )
               RedrawWindow ( k )

            ENDIF

            FOR x := 1 TO ControlCount

               IF _HMG_SYSDATA[138] [x] == hWnd

                  IF _HMG_SYSDATA[135] [x] == "MESSAGEBAR"

                     MoveWindow( _HMG_SYSDATA[137] [x] , 0 , 0 , 0 , 0 , .T. )
                     RefreshItemBar ( _HMG_SYSDATA[137] [x] , _GetStatusItemWidth( hWnd, 1 ) )

                     IF ( k := GetControlIndex( "ProgressMessage", GetParentFormName( x ) ) ) <> 0
                        RefreshProgressItem ( _HMG_SYSDATA[171] [k, 1], _HMG_SYSDATA[137] [k], _HMG_SYSDATA[171] [k, 2] )
                     ENDIF
                     EXIT

                  ENDIF

               ENDIF

            next

            IF _HMG_SYSDATA[29] == .T.

               IF wParam == 2

                  _DoWindowEventProcedure ( _HMG_SYSDATA[130] [i], i )

                  IF _HMG_SYSDATA[414] .AND. _HMG_SYSDATA[13] == 0
                     _Autoadjust( hWnd )
                  ENDIF

               ELSEIF wParam == 1

                  _DoWindowEventProcedure ( _HMG_SYSDATA[131] [i], i )

               ELSEIF wParam == 0 .AND. !IsWindowSized( hWnd )

                  _DoWindowEventProcedure ( _HMG_SYSDATA[132] [i], i )

               ELSE

                  _DoWindowEventProcedure ( _HMG_SYSDATA[103] [i], i )

                  IF _HMG_SYSDATA[414] .AND. _HMG_SYSDATA[13] == 0
                     _Autoadjust( hWnd )
                  ENDIF

               ENDIF

            ENDIF

      ENDIF

      FOR i := 1 TO ControlCount

         IF _HMG_SYSDATA[138] [i] == hWnd

            IF _HMG_SYSDATA[135] [i] == "TOOLBAR"
               SendMessage ( _HMG_SYSDATA[137] [i], 1057, 0, 0 )
            ENDIF

         ENDIF

      next

      nResult := 0
      EXIT

   OTHERWISE
      nResult := Events( hWnd, nMsg, wParam, lParam )

   end

RETURN nResult


FUNCTION AShuffle( aArray )










   LOCAL n, i, j, a := {}

   IF ( n := Len( aArray ) ) > 1

      FOR i := 1 TO n

         while .T.
            j := Random( n )
            IF AScan( a, j ) == 0
               AAdd( a, j )
            ENDIF
         IF !Len( a ) < i ; EXIT ; END ; ENDDO

         j := aArray[ i ]
         aArray[ i ] := aArray[ a[ i ] ]
         aArray[ a[ i ] ] := j

      next

   ENDIF

RETURN aArray





#pragma BEGINDUMP

#include <mgdefs.h>

RECT *Param2Rect( int iParam, RECT *prct )
/*
   Converts a Harbour array parameter to a RECT structure.
 
   Parameters:
       iParam - The index of the Harbour array parameter
       prct   - A pointer to the RECT structure to be filled
 
   Return:
       A pointer to the filled RECT structure.
*/
{
   if( hb_pcount() >= iParam && HB_ISARRAY( iParam ) )
   {
      prct->top = hb_parvnl( iParam, 1 );
      prct->left = hb_parvnl( iParam, 2 );
      prct->bottom = hb_parvnl( iParam, 3 );
      prct->right = hb_parvnl( iParam, 4 );
   }
   else
   {
      prct->top = 0;
      prct->left = 0;
      prct->bottom = 14;
      prct->right = 0;
   }

   return( prct );
}

HB_FUNC( GETCLIAREARECT )
/*
   This function retrieves the client area rectangle of a window.

   Input parameters:
       hWnd - Handle to the window

   Return value:
       .T. - If the function succeeds
       .F. - If the function fails

       The function also stores the rectangle coordinates in an array passed by reference as the second parameter.
*/
{
   RECT  rect;

   hb_retl( GetClientRect( hmg_par_raw_HWND( 1 ), &rect ) );

   HB_STORVNL( rect.top, 2, 1 );
   HB_STORVNL( rect.left, 2, 2 );
   HB_STORVNL( rect.bottom, 2, 3 );
   HB_STORVNL( rect.right, 2, 4 );
}

HB_FUNC( DRAWTEXTEX )   // ( hDC, cText, aRect, nStyle, [hFont], [nClr], [@nRight] ) --> nHeight
/*
   This function draws formatted text in the specified rectangle.

   Input parameters:
       hDC    - Handle to the device context
       cText  - The text to be drawn
       aRect  - An array containing the rectangle coordinates (top, left, bottom, right)
       nStyle - The formatting options (e.g., DT_SINGLELINE, DT_CALCRECT)
       hFont  - (Optional) Handle to the font to use
       nClr   - (Optional) The color of the text
       nRight - (Optional) Variable to store the right coordinate of the drawn text (used with DT_CALCRECT)

   Return value:
       nHeight - The height of the drawn text
*/
{
   HDC      hDC;
   RECT     rct;
   LPCSTR   szText;
   DWORD    dwStyle;
   int      iLen, iRet = 0;
   HFONT    hFont, hOldFont;
   COLORREF nClr, nOldClr;
   BOOL     bColor = FALSE;
   BOOL     bFont = FALSE;

   if( hb_pcount() > 1 && HB_ISCHAR( 2 ) )
   {
      hDC = hmg_par_raw_HDC( 1 );
      iLen = hb_parclen( 2 );

      Param2Rect( 3, &rct );
      dwStyle = hb_pcount() > 3 && HB_ISNUM( 4 ) ? hb_parnl( 4 ) : DT_NOCLIP | DT_SINGLELINE;

      if( hb_pcount() > 4 && HB_ISNUM( 5 ) && ( GetObjectType( hmg_par_raw_HGDIOBJ( 5 ) ) == OBJ_FONT ) )
      {
         hFont = hmg_par_raw_HFONT( 5 );
         hOldFont = SelectObject( hDC, hFont );
         bFont = TRUE;
      }

      if( hb_pcount() > 5 && HB_ISNUM( 6 ) )
      {
         bColor = TRUE;
         nClr = ( COLORREF ) ( hb_parnl( 6 ) & 0xffffff );
         nOldClr = SetTextColor( hDC, nClr );
      }

      szText = hb_xgrab( iLen + 1 );
      memcpy( ( void * ) szText, ( void * ) hb_parc( 2 ), iLen );

      iRet = DrawTextEx( hDC, ( LPSTR ) szText, iLen, &rct, dwStyle, NULL );

      hb_xfree( ( void * ) szText );

      if( bFont )
      {
         SelectObject( hDC, hOldFont );
      }

      if( bColor )
      {
         SetTextColor( hDC, nOldClr );
      }

      if( hb_pcount() > 6 && HB_ISBYREF( 7 ) && ( dwStyle & DT_CALCRECT ) )
      {
         hb_storni( rct.right, 7 );
      }
   }

   hb_retni( iRet );
}

#pragma ENDDUMP
