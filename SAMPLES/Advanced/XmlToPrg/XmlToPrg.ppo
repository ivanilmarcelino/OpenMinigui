










Memvar aXmlStru
#line 54 "S:\Mega\Dev\32\BCC\Minigui\include\i_var.ch"
  MEMVAR _HMG_SYSDATA
#line 14 "S:\Mega\Dev\32\BCC\Minigui\include\miniprint.ch"
  MEMVAR _HMG_MINIPRINT
#line 21 "XmlToPrg.prg"
Function Main







 _DefineWindow ( "Form_1", "XML To Prg Generator", 0, 0, 1100, 660, .F., .F., .F., .F., .F., {,}, {,},, ,, , ,, , , .F. , .F. , .T. , , .F. , ,, , , ,, , , , , , , , , , .F. , , , , .F. , , , , , .F. , .F. , , , .F. , , , )

    _DefineMainMenu( )
        _DefineMenuPopup( "Xml File" , , , )
            _DefineMenuItem ( "Generate Do_Case.prg from the XML file structure." , {|| Make_DO_CASE()} , , , .F. , .F. ,,,, .F., .F. ,, .F. )
            _DefineMenuItem ( "Generate almost ready to use .prg from the XML file structure." , {|| Make_DO_CASE( 1 )} , , , .F. , .F. ,,,, .F., .F. ,, .F. )
            _DefineMenuItem ( "Convert XML to an Array - example" , {|| xml2Array()} , , , .F. , .F. ,,,, .F., .F. ,, .F. )
        _EndMenuPopup()
    _EndMenu()






    _DefineRichEditBoxEx ( "Rich_edit_1",, 10, 10, 1050, 580, "" , "Consolas", 9 , , , , , , .F. , .F. ,, .F., .F. ,.F., .F., .F., .F. , , , .F. , .F. , , , )

     SetProperty ( "Form_1", "Rich_edit_1" , "AutoURLDetect" , .F. )

_EndWindow ()

_ActivateWindow ( {"Form_1"}, .F., , )

Return Nil


Function Xml2Array ()
Local cXmlString, cXmlFile, aXML := {}, i, cPath, cKey, xValue, hAttrib

SetProperty ( "Form_1", "Rich_edit_1" , "Value" , "" )

cXmlFile := GetFile( {{"XML File", "*.xml"}}, "Select XML", hb_CWD(), .F. , .T. )

IF EMPTY( cXmlFile )
    RETURN Nil
ENDIF

cXmlString := FileStr( cXmlFile )

hb_XMLParser( cXmlString, .T., { | aRowXML | AAdd ( aXml, aRowXML) } )

FOR i := 1 TO Len ( aXML )
    cPath   := aXML [ i ] [ 1 ]
    cKey    := aXML [ i ] [ 2 ]
    xValue  := aXML [ i ] [ 3 ]
    hAttrib := aXML [ i ] [ 4 ]

    IF i == 1
        SetProperty ( "Form_1", "Rich_edit_1" , "FontBold" , .T. )
        SetProperty ( "Form_1", "Rich_edit_1" , "AddText" , GetProperty ( "Form_1", "Rich_edit_1" , "GetTextLength" ) , Chr (9) + "--- First ---" + CHR(13)+CHR(10) )
        SetProperty ( "Form_1", "Rich_edit_1" , "FontBold" , .F. )
    ENDIF



    SetProperty ( "Form_1", "Rich_edit_1" , "AddText" , GetProperty ( "Form_1", "Rich_edit_1" , "GetTextLength" ) , "Key Path:" + Chr (9) + '"' + cPath + '"' + CHR(13)+CHR(10) + CHR(13)+CHR(10) +     "Key:" + Chr (9) + Chr (9) + '"' + cKey + '"' + CHR(13)+CHR(10) + CHR(13)+CHR(10) +     "Value:" + Chr (9) + Chr (9) + Left ( hb_ValToStr( xValue ), 100 ) + CHR(13)+CHR(10) + CHR(13)+CHR(10) )
    IF Len( hAttrib ) > 0
        SetProperty ( "Form_1", "Rich_edit_1" , "AddText" , GetProperty ( "Form_1", "Rich_edit_1" , "GetTextLength" ) , "Attribute(s):" + Chr (9) +hb_JsonEncode ( hAttrib ) + CHR(13)+CHR(10) )
    ENDIF

    SetProperty ( "Form_1", "Rich_edit_1" , "FontBold" , .T. )
    SetProperty ( "Form_1", "Rich_edit_1" , "AddText" , GetProperty ( "Form_1", "Rich_edit_1" , "GetTextLength" ) , Chr (9) + IF( i < Len ( aXML ), "--- Next ---", "--- Last ---" ) + CHR(13)+CHR(10) )
    SetProperty ( "Form_1", "Rich_edit_1" , "FontBold" , .F. )

next
Return Nil


Function Make_DO_CASE( nMode )
Local cXmlString, cXmlFile
Local cPrgFile, cBody := "", cSourcePrg := RCDataToMem ( "SourcePrg", 10 )
nMode := iif( nMode == NIL, 0, nMode )

SetProperty ( "Form_1", "Rich_edit_1" , "Value" , "" )


cXmlFile := GetFile( {{"XML File", "*.xml"}}, "Select XML", hb_CWD(), .F. , .T. )

IF EMPTY( cXmlFile )
    RETURN Nil
ENDIF


IF nMode = 0
    cPrgFile := "Do_Case.prg"
ELSE
    cPrgFile := hb_FNameName ( cXmlFile ) + ".prg"
ENDIF

IF nMode == 1







    cBody += hb_StrExtract ( cSourcePrg, "** " + "Code snippet #1 **", "** " + "Code snippet #1 - End **" ) + CHR(13)+CHR(10) +     "Local cXmlFile" + CHR(13)+CHR(10) +     hb_StrExtract ( cSourcePrg, "** " + "Code snippet #2 **", "** " + "Code snippet #2 - End **") + CHR(13)+CHR(10) +     "hb_XMLParser( hb_MemoRead ( cXmlFile ), .T., { | aRowXML | Parser_" +  + hb_FNameName ( cXmlFile ) + " ( aRowXML ) } )" + CHR(13)+CHR(10) + CHR(13)+CHR(10) +     "Return Nil" + CHR(13)+CHR(10) +     "*******************************************************"  + CHR(13)+CHR(10) +    "Function Parser_" + hb_FNameName ( cXmlFile ) + " ( aXmlOneRow ) " + CHR(13)+CHR(10) +     hb_StrExtract ( cSourcePrg, "** " + "Code snippet #3 **", "** " + "Code snippet #3 - End **") + CHR(13)+CHR(10)
ENDIF


cBody +=  "****** DO CASE for the " + hb_FNameNameExt ( cXmlFile ) + " file structure ********" + CHR(13)+CHR(10) +     "DO CASE" + CHR(13)+CHR(10)

STRFILE (cBody, cPrgFile, .F. )

Private aXmlStru := {}

cXmlString := FileStr( cXmlFile )

hb_XMLParser( cXmlString, .T., { | aRowXML | MakeItInRunTime ( aRowXML, cPrgFile ) } )

cBody := "END CASE" + CHR(13)+CHR(10)

IF nMode = 1

    cBody += "Return" + CHR(13)+CHR(10) +     hb_StrExtract ( cSourcePrg, "** " + "Code snippet #4 **", "** " + "Code snippet #4 - End **")
ENDIF

STRFILE ( cBody , cPrgFile, .T. )

SetProperty ( "Form_1", "Rich_edit_1" , "Value" , hb_MemoRead ( cPrgFile ) )

Return Nil


Function MakeItInRunTime ( aXmlOneRow, cFile )
Local Attrib_Key, cPath, cKey, xValue, hAttrib


cPath   := aXmlOneRow [ 1 ]
cKey    := aXmlOneRow [ 2 ]
xValue  := aXmlOneRow [ 3 ]
hAttrib := aXmlOneRow [ 4 ]


IF hb_AScan ( aXmlStru, cPath + "/" + cKey, , , .T. ) = 0
    AAdd( aXmlStru, cPath + "/" + cKey)
    STRFILE ( Chr (9) + 'CASE cKey == "' + cKey + '" .AND. cPath == "' + cPath + '"' + CHR(13)+CHR(10) + Chr (9) + Chr (9) + CHR(13)+CHR(10) , cFile , .T. )
    IF LEN( hAttrib ) > 0
        FOR EACH Attrib_Key IN hb_HKeys ( hAttrib )


            STRFILE ( Chr (9) + Chr (9) + 'IF hb_HHasKey( hAttrib, "' + Attrib_Key + '" )' + CHR(13)+CHR(10) +     Chr (9) + Chr (9) + Chr (9) + 'xAttribValue := hAttrib ["' + Attrib_Key + '"] ' + CHR(13)+CHR(10) + Chr (9) + Chr (9) + Chr (9) + CHR(13)+CHR(10) +     Chr (9) + Chr (9) + "ENDIF" + CHR(13)+CHR(10) + CHR(13)+CHR(10) , cFile, .T. )
        NEXT
    ENDIF
ENDIF

Return Nil





STATIC FUNCTION hb_XMLParser( cXML, lOmitHeader, xFunction )
LOCAL pXML

lOmitHeader := iif( lOmitHeader == NIL, .T., lOmitHeader )

pXML := mxmlLoadString( NIL, hb_utf8ToStr( cXML ), 2 )
IF !Empty( pXML )
    IF lOmitHeader
        hb_XMLParser_getnodes( mxmlGetFirstChild( pXML ), xFunction )
    ELSE
        hb_XMLParser_getnodes( pXML, xFunction )
    ENDIF
ENDIF

mxmlDelete( pXML )

RETURN Nil



STATIC FUNCTION hb_XMLParser_getnodes( pNode, xFunction )
LOCAL cKey, pChild, xResult, xValue, cPrevKey, hAttrib, pParrentNode, cPath

while !Empty( pNode )

    IF mxmlGetType( pNode ) == 0

        cKey   := mxmlGetElement( pNode )
        pChild := mxmlGetFirstChild( pNode )

        IF hb_mxmlGetAttrsCount ( pNode ) > 0 .AND. !Empty( pChild ) .AND. ( mxmlGetOpaque( pNode ) = CHR(13)+CHR(10) .OR. Empty ( mxmlGetOpaque( pNode ) ) )

            cPath := ""
            pParrentNode := mxmlGetParent( pNode )

            IF Left ( cKey, 8 ) == "![CDATA["
                cKey         := mxmlGetElement( mxmlGetParent( pNode ) )
                pParrentNode := mxmlGetParent( mxmlGetParent( pNode ) )
            ENDIF

            while !EMPTY ( pParrentNode )
                cPrevkey := mxmlGetElement( pParrentNode )
                IF Left ( cPrevkey, 4 ) <> "?xml"
                    cPath := cPrevkey + IF( !Empty( cPath ), "/", "") + cPath
                ENDIF
                pParrentNode := mxmlGetParent( pParrentNode )
            ENDDO
            hAttrib := hb_mxmlGetAttrs( pNode )
            IF HB_ISEVALITEM( xFunction )
                Eval( xFunction, { cPath, cKey, Nil, hAttrib } )
            ENDIF

        ENDIF

        xValue := hb_XMLParser_getnodes( pChild, xFunction )

        IF xValue == NIL
            xValue := mxmlGetOpaque( pNode )

            IF !(xValue == CHR(13)+CHR(10))
                cPath        := ""
                pParrentNode := mxmlGetParent( pNode )

                IF Left ( cKey, 8 ) == "![CDATA["
                    xValue       := hb_StrShrink ( mxmlGetCDATA( pNode ), 2 )
                    cKey         := mxmlGetElement( mxmlGetParent( pNode ) )
                    pParrentNode := mxmlGetParent( mxmlGetParent( pNode ) )
                ENDIF

                while !EMPTY ( pParrentNode )
                    cPrevkey := mxmlGetElement( pParrentNode )
                    IF Left ( cPrevkey, 4 ) <> "?xml"
                        cPath := cPrevkey + IF( !Empty( cPath ), "/", "") + cPath
                    ENDIF
                    pParrentNode := mxmlGetParent( pParrentNode )
                ENDDO
                hAttrib := hb_mxmlGetAttrs( pNode )
                IF HB_ISEVALITEM( xFunction )
                    Eval( xFunction, { cPath, cKey, xValue, hAttrib } )
                ENDIF
                xResult := { cPath, cKey, xValue, hAttrib }
            ENDIF
        ENDIF

    ENDIF
    pNode := mxmlGetNextSibling( pNode )
ENDDO
RETURN xResult




Static Function hb_StrExtract ( cString, cFrom, cTo )
Local nFromPos, nToPos
cFrom := iif( cFrom == NIL, "", cFrom ) ; cTo := iif( cTo == NIL, "", cTo )
nFromPos := hb_utf8At ( Upper( cFrom ), Upper ( cString ) ) + hb_utf8Len( cFrom )
nToPos   := hb_utf8RAt( Upper( cTo )  , Upper ( cString ) ) - nFromPos
Return hb_utf8Substr( cString, nFromPos, nToPos )
