#define _WIN32_IE    0x0500
#define _WIN32_WINNT 0x0400

#include <mgdefs.h>
#include <commctrl.h>

#ifdef UNICODE
LPWSTR               AnsiToWide( LPCSTR );
LPSTR                WideToAnsi( LPWSTR );
#endif

BOOL                 Array2Rect( PHB_ITEM aRect, RECT *rc );
PHB_ITEM             Rect2Array( RECT *rc );

// MiniGUI Resources control
void                 RegisterResource( HANDLE hResource, LPCSTR szType );
void pascal          DelResource( HANDLE hResource );

static far BYTE HandXor[] = {
   0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00,
   0x03, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x03, 0x60, 0x00, 0x00, 0x03, 0x6C, 0x00, 0x00,
   0x03, 0x6D, 0x00, 0x00, 0x03, 0x6D, 0x80, 0x00, 0x33, 0xFD, 0x80, 0x00, 0x3B, 0xFF, 0x80, 0x00,
   0x1B, 0xFF, 0x80, 0x00, 0x0B, 0xFF, 0x80, 0x00, 0x0F, 0xFF, 0x80, 0x00, 0x07, 0xFF, 0x80, 0x00,
   0x07, 0xFF, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x03, 0xFF, 0x00, 0x00, 0x01, 0xFE, 0x00, 0x00,
   0x01, 0xFE, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
};

static far BYTE HandAnd[] = {
   0xFC, 0xFF, 0xFF, 0xFF, 0xF8, 0x7F, 0xFF, 0xFF, 0xF8, 0x7F, 0xFF, 0xFF, 0xF8, 0x7F, 0xFF, 0xFF,
   0xF8, 0x7F, 0xFF, 0xFF, 0xF8, 0x1F, 0xFF, 0xFF, 0xF8, 0x03, 0xFF, 0xFF, 0xF8, 0x00, 0xFF, 0xFF,
   0xF8, 0x00, 0x7F, 0xFF, 0x88, 0x00, 0x3F, 0xFF, 0x80, 0x00, 0x3F, 0xFF, 0x80, 0x00, 0x3F, 0xFF,
   0xC0, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x3F, 0xFF, 0xE0, 0x00, 0x3F, 0xFF, 0xF0, 0x00, 0x3F, 0xFF,
   0xF0, 0x00, 0x7F, 0xFF, 0xF8, 0x00, 0x7F, 0xFF, 0xF8, 0x00, 0x7F, 0xFF, 0xFC, 0x00, 0xFF, 0xFF,
   0xFC, 0x00, 0xFF, 0xFF, 0xFC, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
};

static far BYTE StopXor[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x01, 0xF8, 0x00, 0x00, 0x06, 0x06, 0x00, 0x00, 0x08, 0x01, 0x00, 0x00, 0x11, 0xF8, 0x80,
   0x00, 0x26, 0x08, 0x40, 0x00, 0x24, 0x12, 0x40, 0x00, 0x48, 0x25, 0x20, 0x00, 0x48, 0x49, 0x20,
   0x00, 0x48, 0x91, 0x20, 0x00, 0x49, 0x21, 0x20, 0x00, 0x4A, 0x41, 0x20, 0x00, 0x24, 0x82, 0x40,
   0x00, 0x21, 0x06, 0x40, 0x00, 0x11, 0xF8, 0x80, 0x00, 0x08, 0x01, 0x00, 0x00, 0x06, 0x06, 0x00,
   0x00, 0x01, 0xF8, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00
};

static far BYTE StopAnd[] = {
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFE, 0x07, 0xFF, 0xFF, 0xF8, 0x01, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xE0, 0x00, 0x7F,
   0xFF, 0xC1, 0xF0, 0x3F, 0xFF, 0xC3, 0xE0, 0x3F, 0xFF, 0x87, 0xC2, 0x1F, 0xFF, 0x87, 0x86, 0x1F,
   0xFF, 0x87, 0x0E, 0x1F, 0xFF, 0x86, 0x1E, 0x1F, 0xFF, 0x84, 0x3E, 0x1F, 0xFF, 0xC0, 0x7C, 0x3F,
   0xFF, 0xC0, 0xF8, 0x3F, 0xFF, 0xE0, 0x00, 0x7F, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF8, 0x01, 0xFF,
   0xFF, 0xFE, 0x07, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF
};

static far BYTE CatchXor[] = {
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0x00, 0x00, 0x00, 0x1B, 0xB0, 0x00, 0x00, 0x1D,
   0xD8, 0x00, 0x00, 0x0E, 0xDA, 0x00, 0x00, 0x06, 0xEA, 0x00, 0x00, 0x07, 0x6D, 0x00, 0x00, 0x03,
   0x6D, 0x00, 0x00, 0x03, 0x6D, 0x00, 0x01, 0x83, 0x6D, 0x00, 0x01, 0x83, 0x6D, 0x00, 0x01, 0x83,
   0xFF, 0x00, 0x01, 0xC3, 0xFF, 0x00, 0x00, 0xE7, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x7F,
   0xFE, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x3F, 0xFC, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x13, 0xFC, 0x00, 0x00, 0x13, 0xFC, 0x00, 0x00, 0x1F,
   0xFC, 0x00, 0x00, 0x1F, 0xFC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static far BYTE CatchAnd[] = {
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFC, 0xFF, 0xFF, 0xFF, 0xE0, 0x4F, 0xFF, 0xFF, 0xC0, 0x07, 0xFF, 0xFF, 0xC0,
   0x01, 0xFF, 0xFF, 0xE0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0xFF, 0xFF, 0xF0, 0x00, 0x7F, 0xFF, 0xF8,
   0x00, 0x7F, 0xFE, 0x78, 0x00, 0x7F, 0xFC, 0x38, 0x00, 0x7F, 0xFC, 0x38, 0x00, 0x7F, 0xFC, 0x38,
   0x00, 0x7F, 0xFC, 0x18, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x7F, 0xFE, 0x00, 0x00, 0x7F, 0xFF, 0x00,
   0x00, 0xFF, 0xFF, 0x00, 0x00, 0xFF, 0xFF, 0x80, 0x01, 0xFF, 0xFF, 0xC0, 0x01, 0xFF, 0xFF, 0xE0,
   0x03, 0xFF, 0xFF, 0xC0, 0x01, 0xFF, 0xFF, 0xC0, 0x01, 0xFF, 0xFF, 0xC0, 0x01, 0xFF, 0xFF, 0xC0,
   0x01, 0xFF, 0xFF, 0xC0, 0x01, 0xFF, 0xFF, 0xE0, 0x03, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

static far BYTE DragXor[] = {
   0x00, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00, 0x60, 0x00,
   0x00, 0x00, 0x70, 0x00, 0x00, 0x00, 0x78, 0x00, 0x00, 0x00, 0x7C, 0x00, 0x00, 0x00, 0x7E, 0x00,
   0x00, 0x00, 0x7F, 0x00, 0x00, 0x00, 0x7F, 0x80, 0x00, 0x00, 0x7F, 0xC0, 0x00, 0x00, 0x7E, 0x00,
   0x00, 0x00, 0x76, 0x00, 0x00, 0x00, 0x66, 0x00, 0x00, 0x00, 0x43, 0x00, 0x00, 0x00, 0x03, 0x00,
   0x00, 0x00, 0x09, 0x8A, 0x00, 0x00, 0x11, 0x85, 0x00, 0x00, 0x08, 0xC2, 0x00, 0x00, 0x10, 0xC1,
   0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x10, 0x01, 0x00, 0x00, 0x08, 0x02, 0x00, 0x00, 0x15, 0x55,
   0x00, 0x00, 0x0A, 0xAA, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
   0x00, 0x00, 0x00, 0x00, 0x00, 0x00 };

static far BYTE DragAnd[] = {
   0x3F, 0xFF, 0xFF, 0xFF, 0x1F, 0xFF, 0xFF, 0xFF, 0x0F, 0xFF,
   0xFF, 0xFF, 0x07, 0xFF, 0xFF, 0xFF, 0x03, 0xFF, 0xFF, 0xFF, 0x01, 0xFF, 0xFF, 0xFF, 0x00, 0xFF,
   0xFF, 0xFF, 0x00, 0x7F, 0xFF, 0xFF, 0x00, 0x3F, 0xFF, 0xFF, 0x00, 0x1F, 0xFF, 0xFF, 0x00, 0x0F,
   0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x00, 0xFF, 0xFF, 0xFF, 0x18, 0x7F, 0xFF, 0xFF, 0x18, 0x7F,
   0xFF, 0xFF, 0x64, 0x20, 0xFF, 0xFF, 0xE4, 0x38, 0xFF, 0xFF, 0xE6, 0x1C, 0xFF, 0xFF, 0xE6, 0x1C,
   0xFF, 0xFF, 0xE7, 0x3C, 0xFF, 0xFF, 0xE7, 0xFC, 0xFF, 0xFF, 0xE7, 0xFC, 0xFF, 0xFF, 0xE0, 0x00,
   0xFF, 0xFF, 0xE0, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF,
   0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF };

static far HCURSOR   hHand = NULL;
static far HCURSOR   hStop = NULL;
static far HCURSOR   hCatch = NULL;
static far HCURSOR   hDrag = NULL;

// Function to create a pen with specified style, width, and color
HB_FUNC( CREATEPEN )
{
   int      fnPenStyle = hb_parni( 1 );      // Retrieve pen style parameter
   int      nWidth = hb_parni( 2 );          // Retrieve pen width parameter
   COLORREF crColor = hmg_par_COLORREF( 3 ); // Retrieve pen color parameter

   // Create a pen using CreatePen API and return its handle
   hmg_ret_raw_HANDLE( CreatePen( fnPenStyle, nWidth, crColor ) );
}

// Function to move the drawing position to a specified point
HB_FUNC( MOVETO )
{
   POINT pt;               // Structure to store the previous position

   // Call MoveToEx to move the drawing position and return the result as a boolean
   hb_retl( MoveToEx( hmg_par_raw_HDC( 1 ), hmg_par_INT( 2 ), hmg_par_INT( 3 ), &pt ) );
}

// Function to draw a line from the current position to the specified point
HB_FUNC( LINETO )
{
   // Call LineTo to draw the line and return the result as a boolean
   hb_retl( LineTo( hmg_par_raw_HDC( 1 ), hmg_par_INT( 2 ), hmg_par_INT( 3 ) ) );
}

// Function to draw an icon at a specified position
HB_FUNC( DRAWICON )
{
   // Call DrawIcon with HDC, position, and icon handle; return result as boolean
   hb_retl( DrawIcon( hmg_par_raw_HDC( 1 ), hb_parni( 2 ), hb_parni( 3 ), hmg_par_raw_HICON( 4 ) ) );
}

// Function to set the cursor to a horizontal resize cursor
HB_FUNC( CURSORWE )
{
   // Load and set a horizontal resize cursor, returning its handle
   hmg_ret_raw_HANDLE( SetCursor( LoadCursor( 0, IDC_SIZEWE ) ) );
}

// Function to set the cursor to a "size all" cursor
HB_FUNC( CURSORSIZE )
{
   // Load and set a "size all" cursor, returning its handle
   hmg_ret_raw_HANDLE( SetCursor( LoadCursor( 0, IDC_SIZEALL ) ) );
}

// Function to release the mouse capture
HB_FUNC( RELEASECAPTURE )
{
   // Call ReleaseCapture to release mouse input capture, returning result as boolean
   hb_retl( ReleaseCapture() );
}

// Function to invert the colors in a rectangle
HB_FUNC( INVERTRECT )
{
   RECT  rc;               // Rectangle structure
   if( HB_ISARRAY( 2 ) )   // Check if second parameter is an array
   {
      Array2Rect( hb_param( 2, HB_IT_ARRAY ), &rc );           // Convert array to RECT
      InvertRect( hmg_par_raw_HDC( 1 ), &rc );                 // Invert the rectangle
   }
}

// Function to retrieve class information for a window class
HB_FUNC( GETCLASSINFO )
{
#ifndef UNICODE
   LPCSTR   lpString = ( LPCSTR ) hb_parc( 2 );                // Retrieve class name as ANSI string
#else
   LPWSTR   lpString = AnsiToWide( ( char * ) hb_parc( 2 ) );  // Convert ANSI to wide string
   LPSTR    pStr;
#endif
   WNDCLASS WndClass;

   // Retrieve class information using GetClassInfo API
   if( GetClassInfo( HB_ISNIL( 1 ) ? NULL : hmg_par_raw_HINSTANCE( 1 ), lpString, &WndClass ) )
   {
#ifdef UNICODE
      hb_reta( 1 );              // Return array for Unicode
      pStr = WideToAnsi( ( LPWSTR ) WndClass.lpszClassName );
      HB_STORC( pStr, -1, 1 );   // Store class name in return array
      hb_xfree( pStr );          // Free temporary string
#else
      hb_retclen( ( char * ) &WndClass, sizeof( WNDCLASS ) );  // Return structure as string
#endif
   }

#ifdef UNICODE
   hb_xfree( lpString );   // Free allocated wide string
#endif
}

// Function to capture mouse input for a specified window
HB_FUNC( SETCAPTURE )
{
   hmg_ret_raw_HANDLE( SetCapture( hmg_par_raw_HWND( 1 ) ) );
}

// Function to get the current text color
HB_FUNC( GETTEXTCOLOR )
{
   hmg_ret_COLORREF( GetTextColor( hmg_par_raw_HDC( 1 ) ) );
}

// Function to get the current background color
HB_FUNC( GETBKCOLOR )
{
   hmg_ret_COLORREF( GetBkColor( hmg_par_raw_HDC( 1 ) ) );
}

// Function to move or rename a file
HB_FUNC( MOVEFILE )
{
#ifndef UNICODE
   LPCSTR   lpExistingFileName = hb_parc( 1 );  // Get source file name (ANSI)
   LPCSTR   lpNewFileName = hb_parc( 2 );       // Get destination file name (ANSI)
#else
   LPWSTR   lpExistingFileName = AnsiToWide( ( char * ) hb_parc( 1 ) ); // Convert to wide string
   LPWSTR   lpNewFileName = AnsiToWide( ( char * ) hb_parc( 2 ) );
#endif
   hb_retl( MoveFile( lpExistingFileName, lpNewFileName ) );            // Perform the move operation
#ifdef UNICODE
   hb_xfree( lpExistingFileName );        // Free allocated strings
   hb_xfree( lpNewFileName );
#endif
}

// Function to get the current Windows code page
HB_FUNC( GETACP )
{
   hmg_ret_UINT( GetACP() );              // Get the ANSI code page and return it
}

// Function to create and return a "hand" cursor
HB_FUNC( GETCURSORHAND )
{
   if( !hHand )                           // Check if hand cursor is not already created
   {
      hHand = CreateCursor( GetModuleHandle( NULL ), 6, 0, 32, 32, HandAnd, HandXor );
      RegisterResource( hHand, "CUR" );   // Register the cursor as a resource
   }

   hmg_ret_raw_HANDLE( hHand );           // Return the handle
}

// Function to create and return a "drag" cursor
HB_FUNC( GETCURSORDRAG )
{
   if( !hDrag )
   {
      hDrag = CreateCursor( GetModuleHandle( NULL ), 6, 0, 32, 32, DragAnd, DragXor );
      RegisterResource( hDrag, "CUR" );
   }

   hmg_ret_raw_HANDLE( hDrag );
}

// Function to create and return a "catch" cursor
HB_FUNC( GETCURSORCATCH )
{
   if( !hCatch )
   {
      hCatch = CreateCursor( GetModuleHandle( NULL ), 16, 16, 32, 32, CatchAnd, CatchXor );
      RegisterResource( hCatch, "CUR" );
   }

   hmg_ret_raw_HANDLE( hCatch );
}

// Function to create and return a "stop" cursor
HB_FUNC( GETCURSORSTOP )
{
   if( !hStop )
   {
      hStop = CreateCursor( GetModuleHandle( NULL ), 6, 0, 32, 32, StopAnd, StopXor );
      RegisterResource( hStop, "CUR" );
   }

   hmg_ret_raw_HANDLE( hStop );
}

// Function to set the "stop" cursor
HB_FUNC( CURSORSTOP )
{
   if( !hStop )         // Check if "stop" cursor is not already created
   {
      hStop = CreateCursor( GetModuleHandle( NULL ), 6, 0, 32, 32, StopAnd, StopXor );
   }

   SetCursor( hStop );  // Set the "stop" cursor
}

// Function to destroy a cursor and free associated resources
HB_FUNC( DESTROYCURSOR )
{
   HCURSOR  hCur = hmg_par_raw_HCURSOR( 1 ); // Get cursor handle to destroy

   // Clear associated global variables if the cursor matches
   if( hCur == hDrag )
   {
      hDrag = NULL;
   }
   else if( hCur == hCatch )
   {
      hCatch = NULL;
   }
   else if( hCur == hStop )
   {
      hStop = NULL;
   }
   else if( hCur == hHand )
   {
      hHand = NULL;
   }

   DelResource( hCur );                // Unregister the cursor resource
   hb_retl( DestroyCursor( hCur ) );   // Destroy the cursor and return result
}

// Function to get the number of scroll lines for the mouse wheel
HB_FUNC( GETWHEELSCROLLLINES )
{
   UINT  pulScrollLines;

   // Retrieve the number of lines per mouse wheel scroll
   SystemParametersInfo( SPI_GETWHEELSCROLLLINES, 0, &pulScrollLines, 0 );

   hmg_ret_UINT( pulScrollLines );     // Return the result
}
